/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package exercises05;

import org.junit.Test;
import static org.junit.Assert.*;

import java.lang.annotation.Repeatable;
import java.util.concurrent.CyclicBarrier;

import org.junit.Before;

public class TestLongCounter {
    private LongCounter longCounter;
    private CyclicBarrier barrier;

    @Before
    public void initialize() {
        longCounter = new LongCounter();
    }

    @Test
    public void testLongCounterIncrementParallel() {
        var amountOfThreads = 10;
        var iterations = 1000;

        barrier = new CyclicBarrier(amountOfThreads + 1, null);

        for (var i = 0; i < amountOfThreads; i++) {
            new Thread(() -> {
                try {
                    barrier.await();

                    for (var j = 0; j < iterations; j++) {
                        longCounter.increment();
                    }

                    barrier.await();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }

        try {
            barrier.await();
            barrier.await();
        } catch (Exception e) {
            e.printStackTrace();
        }

        assertEquals("LongCounter increment is parallel", iterations * amountOfThreads, longCounter.get());
    }

    @Test
    public void testLongCounterAddParallel() {
        var amountOfThreads = 10;
        var iterations = 1000;

        barrier = new CyclicBarrier(amountOfThreads + 1, null);

        for (var i = 0; i < amountOfThreads; i++) {
            new Thread(() -> {
                try {
                    barrier.await();

                    for (var j = 0; j < iterations; j++) {
                        longCounter.add(2);
                    }

                    barrier.await();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }

        try {
            barrier.await();
            barrier.await();
        } catch (Exception e) {
            e.printStackTrace();
        }

        assertEquals("LongCounter increment is parallel", (iterations * amountOfThreads) * 2, longCounter.get());
    }

    @Test
    public void testLongCounterAddAndIncrementParallel() {
        var amountOfThreads = 10;
        var iterations = 1000;

        barrier = new CyclicBarrier(amountOfThreads + 1, null);

        for (var i = 0; i < amountOfThreads; i++) {
            if (i % 2 == 0) {
                new Thread(() -> {
                    try {
                        barrier.await();

                        for (var j = 0; j < iterations; j++) {
                            longCounter.increment();
                        }

                        barrier.await();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }).start();
            } else {
                new Thread(() -> {
                    try {
                        barrier.await();

                        for (var j = 0; j < iterations; j++) {
                            longCounter.add(1);
                        }

                        barrier.await();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }).start();
            }
        }

        try {
            barrier.await();
            barrier.await();
        } catch (Exception e) {
            e.printStackTrace();
        }

        assertEquals("LongCounter increment is parallel", iterations * amountOfThreads, longCounter.get());
    }
}
